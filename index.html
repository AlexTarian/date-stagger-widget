<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arrival Stagger Widget</title>
  <script>
    function __onJFReadyLoad() {
      if (typeof window.__bindJotformOnce === 'function') window.__bindJotformOnce();
    }
  </script>
  <script async src="https://js.jotform.com/JotFormCustomWidget.min.js?onload=__onJFReadyLoad"></script>
  <style>
    :root {
      --radius: 14px;
      --shadow: 0 6px 24px rgba(0,0,0,.08);
      --border: 1px solid rgba(0,0,0,.08);
      --gap: 10px;
      --pad: 14px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    * { box-sizing: border-box; }
    body { font-family: var(--font); margin: 0; padding: var(--pad); background: #fafafa; color: #111; }
    .widget { max-width: 760px; margin: 0 auto; background: #fff; border-radius: var(--radius); box-shadow: var(--shadow); border: var(--border); overflow: hidden; }
    header { padding: 12px var(--pad); display: flex; align-items: center; justify-content: space-between; border-bottom: var(--border); background: #fcfcfc; }
    header h1 { font-size: 16px; margin: 0; font-weight: 600; }
    header .meta { font-size: 12px; color: #E2E2E2; }
    .content { padding: var(--pad); }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 8px; }
    th { font-size: 12px; color: #555; font-weight: 600; border-bottom: var(--border); }
    tr + tr td { border-top: var(--border); }
    input[type="date"], input[type="number"] { width: 100%; padding: 10px; border-radius: 10px; border: 1px solid #d9d9d9; outline: none; }
    input.zero { border-color: #b00020; color: #b00020; background: #fff5f5; }
    input[type="number"] { -moz-appearance: textfield; }
    input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    .row-controls { display: flex; gap: 6px; justify-content: flex-end; }
    .btn { border-radius: 999px; border: 1px solid #d9d9d9; background: #fff; padding: 10px 14px; cursor: pointer; font-weight: 600; }
    .btn[disabled] { opacity: .5; cursor: not-allowed; }
    
    .btn.danger[disabled] { opacity: .5; }
    .stack { display: flex; gap: var(--gap); align-items: center; flex-wrap: wrap; }
    .footer { display: flex; justify-content: space-between; align-items: center; padding-top: 10px; }
    .pill { font-size: 12px; padding: 6px 10px; border-radius: 999px; background: #f2f2f2; border: 1px solid #e5e5e5; }
    .error { color: #b00020; font-weight: 600; }
    .muted { color: #E2E2E2; }
    .hint { font-size: 12px; color: #555; }
    /* Button color overrides */
  .btn.primary { background: #0047AB !important; color: #fff !important; border-color: #0047AB !important; }
  .btn.primary:hover { filter: brightness(0.95); }
  .btn.danger { background: #c62828 !important; color: #fff !important; border-color: #c62828 !important; }
  .btn.danger:hover { filter: brightness(0.95); }
</style>
</head>
<body>
  <div class="widget" id="widget">
    <header>
      <h1>Staggered Arrivals (v14)</h1>
      <div class="meta" id="jobMeta">Start — End • 0 workers</div>
    </header>
    <div class="content">
      <table>
        <thead>
          <tr>
            <th style="width: 60%">Arrival date</th>
            <th style="width: 30%"># of workers</th>
            <th style="width: 10%"></th>
          </tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>

      <div class="footer">
        <div class="stack">
          <button class="btn primary" id="addRowBtn" type="button">+ Add arrival</button>
          <span class="hint">Minimum 2 rows. No max.</span>
        </div>
        <!-- Debug: what the widget is receiving -->
        <div id="debug-params" style="margin-top:12px; padding:10px; border:1px solid #ddd; border-radius:8px; background:#f8fafc; font:12px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#0f172a;">
          <div><strong>Widget settings</strong> → <span id="dbg-settings">{}</span></div>
          <div><strong>values.keys</strong> → <span id="dbg-keys">[]</span></div>
          <div><strong>Resolved</strong> → start=<span id="dbg-start">(none)</span> &nbsp; end=<span id="dbg-end">(none)</span> &nbsp; total=<span id="dbg-total">(none)</span></div>
          <div id="dbg-note" style="margin-top:6px;color:#475569;">(This panel is for debugging only; you can remove it later.)</div>
        </div>
        <div class="stack">
          <span class="pill">Total selected: <strong id="totalSelected">0</strong></span>
          <span class="pill">Requested: <strong id="totalAllowed">0</strong></span>
        </div>
      </div>

      <div id="status" class="hint" style="margin-top:10px"></div>
    </div>
  </div>
  <script>
    // ===== Elements
    const els = {
      rows: document.getElementById('rows'),
      add: document.getElementById('addRowBtn'),
      totalSelected: document.getElementById('totalSelected'),
      totalAllowed: document.getElementById('totalAllowed'),
      status: document.getElementById('status'),
      jobMeta: document.getElementById('jobMeta'),
    };
  
    // ===== State
    const state = {
      startDate: null,   // yyyy-mm-dd
      endDate: null,     // yyyy-mm-dd
      totalWorkers: 0,
      values: [],        // [{ date: 'yyyy-mm-dd', count: number }]
      minRows: 2,
    };
  
    // ===== Utils
    function fmtMeta() {
      els.jobMeta.textContent = `${state.startDate || 'Start'} — ${state.endDate || 'End'} • ${state.totalWorkers} workers`;
      els.totalAllowed.textContent = String(state.totalWorkers);
    }
    function clampDateToRange(v) {
      if (!v) return v;
      if (state.startDate && v < state.startDate) return state.startDate;
      if (state.endDate && v > state.endDate)     return state.endDate;
      return v;
    }
    function nextDay(iso) {
      if (!iso) return '';
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return '';
      d.setDate(d.getDate() + 1);
      return d.toISOString().slice(0,10);
    }
    function sumSelected() {
      return state.values.reduce((a, r) => a + (Number(r.count) || 0), 0);
    }
  
    // ===== Render
    function render() {
      els.rows.innerHTML = '';
  
      state.values.forEach((row, idx) => {
        const tr = document.createElement('tr');
  
        // Date cell
        const tdDate = document.createElement('td');
        const date = document.createElement('input');
        date.type = 'date';
        date.required = true;
  
        const prevDate = idx > 0 ? (state.values[idx - 1]?.date || null) : null;
        const minForThis = idx === 0 ? state.startDate : (prevDate ? nextDay(prevDate) : state.startDate);
        if (minForThis)    date.min = minForThis;
        if (state.endDate) date.max = state.endDate;
  
        date.value = row.date || '';
        date.addEventListener('change', () => {
          let newVal = clampDateToRange(date.value);
          if (idx > 0) {
            const prev = state.values[idx - 1]?.date;
            if (prev && (!newVal || newVal <= prev)) newVal = nextDay(prev);
          }
          row.date = newVal || '';
          date.value = row.date;
          validateAndEmit();
          render(); // refresh mins for later rows
        });
        tdDate.appendChild(date);
  
        // Number cell
        const tdNum = document.createElement('td');
        const num = document.createElement('input');
        num.type = 'number';
        num.min = '0';
        num.step = '1';
        num.placeholder = '0';
        num.value = row.count ?? '';
        num.classList.toggle('zero', Number(row.count || 0) === 0);
        num.addEventListener('input', () => {
          const v = Math.max(0, Math.floor(Number(num.value || 0)));
          row.count = v;
          num.value = String(v);
          num.classList.toggle('zero', v === 0);
          validateAndEmit();
        });
        tdNum.appendChild(num);
  
        // Actions cell
        const tdActions = document.createElement('td');
        const del = document.createElement('button');
        del.className = 'btn danger';
        del.textContent = 'Remove';
        del.type = 'button';
        del.addEventListener('click', () => removeRow(idx));
        tdActions.appendChild(del);
  
        tr.appendChild(tdDate);
        tr.appendChild(tdNum);
        tr.appendChild(tdActions);
        els.rows.appendChild(tr);
      });
  
      // Footer + controls
      const total = sumSelected();
      els.totalSelected.textContent = String(total);
  
      const canRemove = state.values.length > state.minRows;
      [...els.rows.querySelectorAll('button')].forEach(btn => btn.disabled = !canRemove);
  
      els.add.disabled = (state.totalWorkers > 0 && total >= state.totalWorkers);
    }
  
    // ===== Core actions
    function addRow(prefill = {}) {
      state.values.push({
        date:  prefill.date  ?? '',
        count: prefill.count ?? 0,
      });
      render();
      validateAndEmit();
    }
    function removeRow(idx) {
      if (state.values.length <= state.minRows) return;
      state.values.splice(idx, 1);
      render();
      validateAndEmit();
    }
    function setBounds({ startDate, endDate, totalWorkers }) {
      if (startDate != null)    state.startDate = startDate;
      if (endDate != null)      state.endDate = endDate;
      if (totalWorkers != null) state.totalWorkers = Number(totalWorkers) || 0;
  
      fmtMeta();
      // Snap existing rows to range and order
      state.values.forEach((r, i) => {
        r.date = clampDateToRange(r.date);
        if (i > 0) {
          const prev = state.values[i-1]?.date;
          if (prev && (!r.date || r.date <= prev)) r.date = nextDay(prev);
        }
      });
      render();
      validateAndEmit();
    }
  
    // ===== Validation / serialization
    function validate() {
      const errors = [];
  
      // Dates present, in range, strictly increasing
      for (let i = 0; i < state.values.length; i++) {
        const r = state.values[i];
        if (!r.date) { errors.push('All rows must have a date.'); break; }
        if (state.startDate && r.date < state.startDate) { errors.push('A date is before the job start date.'); break; }
        if (state.endDate && r.date > state.endDate) { errors.push('A date is after the job end date.'); break; }
        if (i > 0) {
          const prev = state.values[i-1].date;
          if (!prev) { errors.push('Earlier rows must be completed first.'); break; }
          if (r.date <= prev) { errors.push('Dates must be strictly increasing with no duplicates.'); break; }
        }
      }
  
      // Totals must equal requested
      const total = sumSelected();
      if (state.totalWorkers > 0 && total !== state.totalWorkers) {
        errors.push(`Total selected (${total}) must equal requested (${state.totalWorkers}).`);
      }
  
      // Minimum rows
      if (state.values.length < state.minRows) errors.push('At least two arrival rows are required.');
  
      return errors;
    }
    function validateAndEmit() {
      const errs = validate();
      if (errs.length) {
        els.status.innerHTML = `<span class="error">${errs[0]}</span>`;
        sendValue({ valid: false, message: errs[0] });
      } else {
        els.status.textContent = 'Looks good. You can submit the form.';
        sendValue({ valid: true });
      }
    }
    function serialize() {
      return state.values.map(r => ({ date: r.date, count: Number(r.count) || 0 }));
    }
  
    // ===== Boot / integration
    els.add.addEventListener('click', () => addRow());
  
    function boot(initialConfig) {
      if (state.values.length === 0) { addRow(); addRow(); }
      if (initialConfig) {
        setBounds(initialConfig);
        if (state.values[0] && !state.values[0].date && initialConfig.startDate) {
          state.values[0].date = initialConfig.startDate;
          render();
          validateAndEmit();
        }
      } else {
        render();
        validateAndEmit();
      }
    }
  
    // Query param testing: ?start=YYYY-MM-DD&end=YYYY-MM-DD&workers=25
    function readQueryConfig() {
      try {
        const u = new URL(location.href);
        const startDate = u.searchParams.get('start') || undefined;
        const endDate   = u.searchParams.get('end')   || undefined;
        const workers   = u.searchParams.get('workers');
        const totalWorkers = workers != null ? Number(workers) : undefined;
        if (startDate || endDate || totalWorkers != null) return { startDate, endDate, totalWorkers };
      } catch (_) {}
      return null;
    }
  
    // ---- Jotform integration (listeners, no polling)
    function tryBindJotform() {
      if (!window.JFCustomWidget) return false;
      const JF = window.JFCustomWidget;
      let didFireReady = false;
      setTimeout(() => {
        if (!didFireReady) {
          const note = document.getElementById('dbg-note');
          if (note) note.textContent = 'JFCustomWidget.ready did not fire; running in fallback.';
          boot({ startDate: '', endDate: '', totalWorkers: 0 });
        }
      }, 1500);
    
      function getSettings(cb){
        try {
          if (typeof JF.getWidgetSettings === 'function') return JF.getWidgetSettings(s => cb(s || {}));
          if (typeof JF.requestSettings === 'function')    return JF.requestSettings(s => cb(s || {}));
        } catch (_) { /* ignore */ }
        cb({});
      }
    
      function readHostValues(settings, cb){
        JF.getFieldsValue(function(values){
          const dbgKeys = document.getElementById('dbg-keys');
          if (dbgKeys) dbgKeys.textContent = JSON.stringify(Object.keys(values || {}));
          
          const dbgStart = document.getElementById('dbg-start');
          const dbgEnd   = document.getElementById('dbg-end');
          const dbgTotal = document.getElementById('dbg-total');
          if (dbgStart) dbgStart.textContent = String(settings.startFieldId || '(missing)');
          if (dbgEnd)   dbgEnd.textContent   = String(settings.endFieldId   || '(missing)');
          if (dbgTotal) dbgTotal.textContent = String(settings.totalWorkersFieldId || '(missing)');
          
          const sId = settings.startFieldId;
          const eId = settings.endFieldId;
          const nId = settings.totalWorkersFieldId;
          const startDate = pickFromValues(values, sId);
          const endDate   = pickFromValues(values, eId);
          const twRaw     = pickFromValues(values, nId);
          const totalWorkers = (twRaw != null && twRaw !== '') ? Number(twRaw) : undefined;
          cb({ startDate, endDate, totalWorkers });
        });
      }
    
      function pushValue(valid, message) {
        try { JF.sendData({ value: JSON.stringify(serialize()), valid, message: message || '' }); } catch (_){}
      }
      window.sendValue = ({ valid, message }) => pushValue(valid, message);
    
      // Initial boot + listeners
      JF.subscribe('ready', function(){
        didFireReady = true;
        getSettings(function(settings){

          const dbgSettings = document.getElementById('dbg-settings');
          if (dbgSettings) dbgSettings.textContent = JSON.stringify(settings || {}, null, 2);
    
          // Live listeners (handle changes instantly)
          attachListeners(JF, settings.startFieldId, (val) => setBounds({ startDate: val }));
          attachListeners(JF, settings.endFieldId,   (val) => setBounds({ endDate: val }));
          attachListeners(JF, settings.totalWorkersFieldId, (val) => setBounds({ totalWorkers: val }));
    
          // Initial values
          readHostValues(settings, function(vals){
            boot(vals);
            pushValue(validate().length === 0);
          });
        });
      });
    
      // Validate on submit
      JF.subscribe('submit', function(){
        const errs = validate();
        pushValue(errs.length === 0, errs[0] || '');
      });
    
      return true;
    }
  
    // Default sendValue for standalone
    window.sendValue = ({ valid, message }) => { /* no-op in standalone */ };

    // Normalize whatever the user typed (QID/unique-name/DOM-ish) into:
    // - candidates we try in getFieldsValue()
    // - keys we listen to with listenFromField()
    function normalizeFieldKey(raw) {
      if (raw == null) return { lookup: [], listen: [] };
      let s = String(raw).trim();
    
      // Strip leading '#' and trailing '_pick' (Jotform date pickers)
      if (s.startsWith('#')) s = s.slice(1);
      s = s.replace(/_pick$/i, '');
    
      // Pure number? That's the question ID. Jotform usually uses input_<QID>.
      if (/^\d+$/.test(s)) {
        const qid = s;
        return {
          lookup: [qid, `input_${qid}`, `q${qid}`], // shapes we may see in getFieldsValue()
          listen: [`input_${qid}`]                  // event source for listenFromField
        };
      }
    
      // If it's input_### already, derive the numeric variants too
      const m = s.match(/^input_(\d+)$/);
      if (m) {
        const qid = m[1];
        return {
          lookup: [qid, s, `q${qid}`],
          listen: [s]
        };
      }
    
      // Otherwise treat as unique name
      return {
        lookup: [s],    // getFieldsValue may expose by unique name
        listen: [s]     // listen by unique name
      };
    }
    
    // Use this to read initial values
    function pickFromValues(values, rawKey) {
      const { lookup } = normalizeFieldKey(rawKey);
      for (const k of lookup) {
        if (Object.prototype.hasOwnProperty.call(values, k)) {
          const v = values[k];
          return (v && typeof v === 'object' && 'value' in v) ? v.value : v;
        }
      }
      return undefined;
    }
    
    // Use this to wire listeners
    function attachListeners(JF, rawKey, handler) {
      const { listen } = normalizeFieldKey(rawKey);
      for (const key of listen) {
        try {
          JF.listenFromField(key, 'change', handler);
          JF.listenFromField(key, 'keyup',  handler);
        } catch (_) {}
      }
    }
    
    let __didBind = false;
    window.__bindJotformOnce = function () {
      if (__didBind) return;
      __didBind = true;
      const bound = tryBindJotform();
      if (!bound) {
        const qc = readQueryConfig();
        boot(qc || { startDate: '', endDate: '', totalWorkers: 0 });
      }
    };
  
    // If JFCustomWidget was already present (rare), bind immediately
    if (window.JFCustomWidget) window.__bindJotformOnce();

  </script>
</body>
</html>












