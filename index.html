<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arrival Stagger Widget</title>
  <style>
    :root {
      --radius: 14px;
      --shadow: 0 6px 24px rgba(0,0,0,.08);
      --border: 1px solid rgba(0,0,0,.08);
      --gap: 10px;
      --pad: 14px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    * { box-sizing: border-box; }
    body { font-family: var(--font); margin: 0; padding: var(--pad); background: #fafafa; color: #111; }
    .widget { max-width: 760px; margin: 0 auto; background: #fff; border-radius: var(--radius); box-shadow: var(--shadow); border: var(--border); overflow: hidden; }
    header { padding: 12px var(--pad); display: flex; align-items: center; justify-content: space-between; border-bottom: var(--border); background: #fcfcfc; }
    header h1 { font-size: 16px; margin: 0; font-weight: 600; }
    header .meta { font-size: 12px; color: #E2E2E2; }
    .content { padding: var(--pad); }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 8px; }
    th { font-size: 12px; color: #555; font-weight: 600; border-bottom: var(--border); }
    tr + tr td { border-top: var(--border); }
    input[type="date"], input[type="number"] { width: 100%; padding: 10px; border-radius: 10px; border: 1px solid #d9d9d9; outline: none; }
    input.zero { border-color: #b00020; color: #b00020; background: #fff5f5; }
    input[type="number"] { -moz-appearance: textfield; }
    input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    .row-controls { display: flex; gap: 6px; justify-content: flex-end; }
    .btn { border-radius: 999px; border: 1px solid #d9d9d9; background: #fff; padding: 10px 14px; cursor: pointer; font-weight: 600; }
    .btn[disabled] { opacity: .5; cursor: not-allowed; }
    
    .btn.danger[disabled] { opacity: .5; }
    .stack { display: flex; gap: var(--gap); align-items: center; flex-wrap: wrap; }
    .footer { display: flex; justify-content: space-between; align-items: center; padding-top: 10px; }
    .pill { font-size: 12px; padding: 6px 10px; border-radius: 999px; background: #f2f2f2; border: 1px solid #e5e5e5; }
    .error { color: #b00020; font-weight: 600; }
    .muted { color: #E2E2E2; }
    .hint { font-size: 12px; color: #555; }
    /* Button color overrides */
  .btn.primary { background: #0047AB !important; color: #fff !important; border-color: #0047AB !important; }
  .btn.primary:hover { filter: brightness(0.95); }
  .btn.danger { background: #c62828 !important; color: #fff !important; border-color: #c62828 !important; }
  .btn.danger:hover { filter: brightness(0.95); }
</style>
</head>
<body>
  <div class="widget" id="widget">
    <header>
      <h1>Staggered Arrivals (v7)</h1>
      <div class="meta" id="jobMeta">Start — End • 0 workers</div>
    </header>
    <div class="content">
      <table>
        <thead>
          <tr>
            <th style="width: 60%">Arrival date</th>
            <th style="width: 30%"># of workers</th>
            <th style="width: 10%"></th>
          </tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>

      <div class="footer">
        <div class="stack">
          <button class="btn primary" id="addRowBtn" type="button">+ Add arrival</button>
          <span class="hint">Minimum 2 rows. No max.</span>
        </div>
        <div class="stack">
          <span class="pill">Total selected: <strong id="totalSelected">0</strong></span>
          <span class="pill">Requested: <strong id="totalAllowed">0</strong></span>
        </div>
      </div>

      <div id="status" class="hint" style="margin-top:10px"></div>
    </div>
  </div>
  <script>
  // ===== Elements
  const els = {
    rows: document.getElementById('rows'),
    add: document.getElementById('addRowBtn'),
    totalSelected: document.getElementById('totalSelected'),
    totalAllowed: document.getElementById('totalAllowed'),
    status: document.getElementById('status'),
    jobMeta: document.getElementById('jobMeta'),
  };

  // ===== State
  const state = {
    startDate: null,   // yyyy-mm-dd
    endDate: null,     // yyyy-mm-dd
    totalWorkers: 0,
    values: [],        // [{ date: 'yyyy-mm-dd', count: number }]
    minRows: 2,
  };

  // ===== Utils
  function fmtMeta() {
    els.jobMeta.textContent = `${state.startDate || 'Start'} — ${state.endDate || 'End'} • ${state.totalWorkers} workers`;
    els.totalAllowed.textContent = String(state.totalWorkers);
  }
  function clampDateToRange(v) {
    if (!v) return v;
    if (state.startDate && v < state.startDate) return state.startDate;
    if (state.endDate && v > state.endDate)     return state.endDate;
    return v;
  }
  function nextDay(iso) {
    if (!iso) return '';
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return '';
    d.setDate(d.getDate() + 1);
    return d.toISOString().slice(0,10);
  }
  function sumSelected() {
    return state.values.reduce((a, r) => a + (Number(r.count) || 0), 0);
  }

  // ===== Render
  function render() {
    els.rows.innerHTML = '';

    state.values.forEach((row, idx) => {
      const tr = document.createElement('tr');

      // Date cell
      const tdDate = document.createElement('td');
      const date = document.createElement('input');
      date.type = 'date';
      date.required = true;

      const prevDate = idx > 0 ? (state.values[idx - 1]?.date || null) : null;
      const minForThis = idx === 0 ? state.startDate : (prevDate ? nextDay(prevDate) : state.startDate);
      if (minForThis)    date.min = minForThis;
      if (state.endDate) date.max = state.endDate;

      date.value = row.date || '';
      date.addEventListener('change', () => {
        let newVal = clampDateToRange(date.value);
        if (idx > 0) {
          const prev = state.values[idx - 1]?.date;
          if (prev && (!newVal || newVal <= prev)) newVal = nextDay(prev);
        }
        row.date = newVal || '';
        date.value = row.date;
        validateAndEmit();
        render(); // refresh mins for later rows
      });
      tdDate.appendChild(date);

      // Number cell
      const tdNum = document.createElement('td');
      const num = document.createElement('input');
      num.type = 'number';
      num.min = '0';
      num.step = '1';
      num.placeholder = '0';
      num.value = row.count ?? '';
      num.classList.toggle('zero', Number(row.count || 0) === 0);
      num.addEventListener('input', () => {
        const v = Math.max(0, Math.floor(Number(num.value || 0)));
        row.count = v;
        num.value = String(v);
        num.classList.toggle('zero', v === 0);
        validateAndEmit();
      });
      tdNum.appendChild(num);

      // Actions cell
      const tdActions = document.createElement('td');
      const del = document.createElement('button');
      del.className = 'btn danger';
      del.textContent = 'Remove';
      del.type = 'button';
      del.addEventListener('click', () => removeRow(idx));
      tdActions.appendChild(del);

      tr.appendChild(tdDate);
      tr.appendChild(tdNum);
      tr.appendChild(tdActions);
      els.rows.appendChild(tr);
    });

    // Footer + controls
    const total = sumSelected();
    els.totalSelected.textContent = String(total);

    const canRemove = state.values.length > state.minRows;
    [...els.rows.querySelectorAll('button')].forEach(btn => btn.disabled = !canRemove);

    els.add.disabled = (state.totalWorkers > 0 && total >= state.totalWorkers);
  }

  // ===== Core actions
  function addRow(prefill = {}) {
    state.values.push({
      date:  prefill.date  ?? '',
      count: prefill.count ?? 0,
    });
    render();
    validateAndEmit();
  }
  function removeRow(idx) {
    if (state.values.length <= state.minRows) return;
    state.values.splice(idx, 1);
    render();
    validateAndEmit();
  }
  function setBounds({ startDate, endDate, totalWorkers }) {
    if (startDate != null)    state.startDate = startDate;
    if (endDate != null)      state.endDate = endDate;
    if (totalWorkers != null) state.totalWorkers = Number(totalWorkers) || 0;
    fmtMeta();
    // Snap existing rows to range and order
    state.values.forEach((r, i) => {
      r.date = clampDateToRange(r.date);
      if (i > 0) {
        const prev = state.values[i-1]?.date;
        if (prev && (!r.date || r.date <= prev)) r.date = nextDay(prev);
      }
    });
    render();
    validateAndEmit();
  }

  // ===== Validation / serialization
  function validate() {
    const errors = [];

    // Dates present, in range, strictly increasing
    for (let i = 0; i < state.values.length; i++) {
      const r = state.values[i];
      if (!r.date) { errors.push('All rows must have a date.'); break; }
      if (state.startDate && r.date < state.startDate) { errors.push('A date is before the job start date.'); break; }
      if (state.endDate && r.date > state.endDate) { errors.push('A date is after the job end date.'); break; }
      if (i > 0) {
        const prev = state.values[i-1].date;
        if (!prev) { errors.push('Earlier rows must be completed first.'); break; }
        if (r.date <= prev) { errors.push('Dates must be strictly increasing with no duplicates.'); break; }
      }
    }

    // Totals must equal requested
    const total = sumSelected();
    if (state.totalWorkers > 0 && total !== state.totalWorkers) {
      errors.push(`Total selected (${total}) must equal requested (${state.totalWorkers}).`);
    }

    // Minimum rows
    if (state.values.length < state.minRows) errors.push('At least two arrival rows are required.');

    return errors;
  }
  function validateAndEmit() {
    const errs = validate();
    if (errs.length) {
      els.status.innerHTML = `<span class="error">${errs[0]}</span>`;
      sendValue({ valid: false, message: errs[0] });
    } else {
      els.status.textContent = 'Looks good. You can submit the form.';
      sendValue({ valid: true });
    }
  }
  function serialize() {
    // Keep rows as-is; validation guarantees strictly increasing unique dates
    return state.values.map(r => ({ date: r.date, count: Number(r.count) || 0 }));
  }

  // ===== Boot / integration
  els.add.addEventListener('click', () => addRow());

  function boot(initialConfig) {
    if (state.values.length === 0) { addRow(); addRow(); }
    if (initialConfig) {
      setBounds(initialConfig);
      if (state.values[0] && !state.values[0].date && initialConfig.startDate) {
        state.values[0].date = initialConfig.startDate;
        render();
        validateAndEmit();
      }
    } else {
      render();
      validateAndEmit();
    }
  }

  // Query param testing: ?start=YYYY-MM-DD&end=YYYY-MM-DD&workers=25
  function readQueryConfig() {
    try {
      const u = new URL(location.href);
      const startDate = u.searchParams.get('start') || undefined;
      const endDate   = u.searchParams.get('end')   || undefined;
      const workers   = u.searchParams.get('workers');
      const totalWorkers = workers != null ? Number(workers) : undefined;
      if (startDate || endDate || totalWorkers != null) return { startDate, endDate, totalWorkers };
    } catch (_) {}
    return null;
  }

  // === Debug helpers (add near top, only once)
  const DEBUG = /[?&]debug=1\b/.test(location.search);
  function dlog(...args) { if (DEBUG) console.log('[ArrivalWidget]', ...args); }
  function derr(...args) { if (DEBUG) console.error('[ArrivalWidget]', ...args); }
  
  function makeDebugPanel() {
    if (!DEBUG || document.getElementById('arrival-debug')) return;
    const box = document.createElement('pre');
    box.id = 'arrival-debug';
    box.style.cssText = 'font:12px ui-monospace,monospace; background:#111; color:#9ef; padding:8px; border-radius:8px; max-height:240px; overflow:auto; margin-top:10px;';
    (document.querySelector('.content') || document.body).appendChild(box);
  }
  function decho(label, obj) {
    if (!DEBUG) return;
    makeDebugPanel();
    const el = document.getElementById('arrival-debug');
    const line = `${label}: ${typeof obj === 'string' ? obj : JSON.stringify(obj, null, 2)}`;
    el.textContent += (el.textContent ? '\n' : '') + line;
  }

  // Jotform integration (supports getWidgetSettings or requestSettings) + polling
  function tryBindJotform() {
    if (!window.JFCustomWidget) {
      dlog('JFCustomWidget missing → running standalone (query params only).');
      return false;
    }
    const JF = window.JFCustomWidget;
    dlog('JFCustomWidget detected.');
  
    // Get settings via either API and log what we get
    function getSettings(cb){
      try {
        if (typeof JF.getWidgetSettings === 'function') {
          return JF.getWidgetSettings((s)=>{ dlog('settings via getWidgetSettings', s); decho('settings', s); cb(s || {}); });
        }
        if (typeof JF.requestSettings === 'function') {
          return JF.requestSettings((s)=>{ dlog('settings via requestSettings', s); decho('settings', s); cb(s || {}); });
        }
      } catch(e) { derr('settings error', e); }
      dlog('settings fallback {}');
      cb({});
    }
  
    // Normalize Jotform values; logs raw values + keys and the resolved picks
    function readHostValues(settings, cb){
      JF.getFieldsValue(function(values){
        dlog('raw values', values);
        decho('values.keys', Object.keys(values || {}));
  
        const sKey = settings.startFieldId;
        const eKey = settings.endFieldId;
        const nKey = settings.totalWorkersFieldId;
  
        const pick = (key) => {
          if (!key) return undefined;
          const candidates = [ String(key), `input_${key}`, `q${key}` ];
          for (const c of candidates) {
            if (Object.prototype.hasOwnProperty.call(values, c)) {
              const v = values[c];
              dlog('pick hit', { key, candidate: c, value: v });
              return (v && typeof v === 'object' && 'value' in v) ? v.value : v;
            }
          }
          // last-resort: direct match on unique name (case-insensitive)
          const lower = String(key).toLowerCase();
          for (const k of Object.keys(values)) {
            if (k.toLowerCase() === lower) {
              const v = values[k];
              dlog('pick uniqueName hit', { key, candidate: k, value: v });
              return (v && typeof v === 'object' && 'value' in v) ? v.value : v;
            }
          }
          dlog('pick miss', { key, tried: candidates });
          return undefined;
        };
  
        const startDate = pick(sKey);
        const endDate   = pick(eKey);
        const twRaw     = pick(nKey);
        const totalWorkers = (twRaw != null && twRaw !== '') ? Number(twRaw) : undefined;
  
        const resolved = { startDate, endDate, totalWorkers };
        dlog('resolved params', resolved);
        decho('resolved', resolved);
  
        cb(resolved);
      });
    }
  
    function pushValue(valid, message) {
      try {
        JF.sendData({ value: JSON.stringify(serialize()), valid, message: message || '' });
        dlog('sendData', { valid, message });
      } catch (e) { derr('sendData error', e); }
    }
    window.sendValue = ({ valid, message }) => pushValue(valid, message);
  
    // Initial boot
    JF.subscribe('ready', function(){
      dlog('JF → ready');
      getSettings(function(settings){
        readHostValues(settings, function(vals){
          dlog('boot with', vals);
          decho('boot', vals);
          boot(vals);
          pushValue(validate().length === 0);
        });
      });
    });
  
    // Live sync every 800ms; log changes
    let last = { startDate: undefined, endDate: undefined, totalWorkers: undefined };
    const sync = () => {
      getSettings(function(settings){
        readHostValues(settings, function(vals){
          const changed =
            vals.startDate !== last.startDate ||
            vals.endDate   !== last.endDate   ||
            Number(vals.totalWorkers || 0) !== Number(last.totalWorkers || 0);
          if (changed) {
            dlog('sync change', { from: last, to: vals });
            decho('sync change', { from: last, to: vals });
            last = { ...vals };
            setBounds(vals);
          }
        });
      });
    };
    const syncInterval = setInterval(sync, 800);
  
    // Validate on submit
    JF.subscribe('submit', function(){
      dlog('JF → submit');
      const errs = validate();
      pushValue(errs.length === 0, errs[0] || '');
      try { clearInterval(syncInterval); } catch(_) {}
    });
  
    return true;
  }

  // Default sendValue for standalone
  window.sendValue = ({ valid, message }) => { /* no-op in standalone */ };

  // Init priority: Jotform → query params → defaults
  const bound = tryBindJotform();
  if (!bound) {
    const qc = readQueryConfig();
    boot(qc || { startDate: '', endDate: '', totalWorkers: 0 });
  }
</script>
</body>
</html>




