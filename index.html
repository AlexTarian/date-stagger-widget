<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Arrival Stagger</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://js.jotform.com/JotFormCustomWidget.min.js"></script>
  <style>
    :root { --r:12px; --b:1px solid #e5e7eb; --pad:14px; --font: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
    *{box-sizing:border-box}
    body{margin:0;padding:var(--pad);background:#fafafa;font:14px var(--font);color:#111}
    .card{max-width:760px;margin:0 auto;background:#fff;border:var(--b);border-radius:var(--r);box-shadow:0 6px 20px rgba(0,0,0,.06);overflow:hidden}
    header{display:flex;justify-content:space-between;align-items:center;padding:10px var(--pad);background:#fbfbfc;border-bottom:var(--b)}
    h1{font-size:15px;margin:0;font-weight:600}
    .meta{font-size:12px;color:#6b7280}
    .content{padding:var(--pad)}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px;text-align:left}
    th{font-size:12px;color:#52525b;border-bottom:var(--b)}
    tr+tr td{border-top:var(--b)}
    input[type="date"],input[type="number"]{width:100%;padding:10px;border:1px solid #d4d4d8;border-radius:10px;outline:none}
    input.zero{border-color:#b00020;color:#b00020;background:#fff5f5}
    .row-actions{display:flex;justify-content:flex-end}
    .btn{border:1px solid #d4d4d8;background:#fff;border-radius:999px;padding:8px 14px;font-weight:600;cursor:pointer}
    .btn.primary{background:#0047AB;border-color:#0047AB;color:#fff}
    .btn.danger{background:#c62828;border-color:#c62828;color:#fff}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .footer{margin-top:12px;display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap}
    .pill{font-size:12px;padding:6px 10px;border-radius:999px;background:#f3f4f6;border:1px solid #e5e7eb}
    .hint{font-size:12px;color:#6b7280}
    .error{color:#b00020;font-weight:600}
  </style>
</head>
<body>
  <div class="card">
    <header>
      <h1>Staggered Arrivals (v3)</h1>
      <div class="meta" id="meta">Start — End • 0 workers</div>
    </header>

    <div class="content">
      <table>
        <thead>
          <tr>
            <th style="width:60%">Arrival date</th>
            <th style="width:30%"># of workers</th>
            <th style="width:10%"></th>
          </tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>

      <div class="footer">
        <div style="display:flex; gap:8px; align-items:center;">
          <button class="btn primary" id="addRow" type="button">+ Add arrival</button>
          <span class="hint">Minimum 2 rows. No max.</span>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <span class="pill">Total selected: <strong id="totalSelected">0</strong></span>
          <span class="pill">Requested: <strong id="totalAllowed">0</strong></span>
        </div>
      </div>

      <div id="status" class="hint" style="margin-top:8px"></div>
    </div>
  </div>

  <script>
  (function(){
    // ---------- DOM ----------
    const $ = (id) => document.getElementById(id);

    // ---------- state ----------
    const state = {
      startDate: '',        // yyyy-mm-dd
      endDate: '',          // yyyy-mm-dd
      totalWorkers: 0,      // number (from a Short Text field in JF)
      values: [],           // [{ date:'yyyy-mm-dd', count:Number }]
      minRows: 2
    };

    // ---------- utils ----------
    const toQID = (raw) => {
      const s = String((raw && (raw.value ?? raw)) || '').trim().replace(/^#/, '');
      const m = s.match(/^input_(\d+)$/i) || s.match(/^(\d+)$/);
      return m ? m[1] : null;
    };

    // Normalize any “MM/DD/YYYY” or “YYYY-MM-DD” to “YYYY-MM-DD”
    function toISO(d){
      if (!d) return '';
      if (/^\d{4}-\d{2}-\d{2}$/.test(d)) return d;
      const m = d.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/); // MM/DD/YYYY
      if (m){
        const [ , mm, dd, yyyy ] = m;
        const mm2 = String(mm).padStart(2,'0');
        const dd2 = String(dd).padStart(2,'0');
        return `${yyyy}-${mm2}-${dd2}`;
      }
      // Last resort: Date parse
      const dt = new Date(d);
      if (!Number.isNaN(dt.getTime())) return dt.toISOString().slice(0,10);
      return '';
    }

    function fromISOToNice(iso){
      if (!iso) return '';
      const [y,m,d] = iso.split('-');
      return `${m}/${d}/${y}`;
    }

    function readByIdOnce(qid, cb){
      if (!qid) return cb('');
      try {
        JFCustomWidget.getFieldsValueById([qid], (res)=>{
          let map = {};
          if (res && res.type === 'event:receiver') {
            (res.data || []).forEach(r => { map[String(r.selector)] = (r.value && r.value.value) ? r.value.value : r.value; });
          } else {
            map = res || {};
          }
          cb(map[qid] ?? '');
        });
      } catch(_) { cb(''); }
    }

    function startWatcher(qid, onChange, interval=400){
      if (!qid) return ()=>{};
      let last = Symbol('first'), stop = false;
      (function tick(){
        if (stop) return;
        readByIdOnce(qid, val => {
          const iso = toISO(val);
          if (iso !== last) { last = iso; onChange(iso); }
          setTimeout(tick, interval);
        });
      })();
      return ()=>{ stop = true; };
    }

    function nextDay(iso){
      if (!iso) return '';
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return '';
      d.setDate(d.getDate()+1);
      return d.toISOString().slice(0,10);
    }

    function clampDate(v){
      if (!v) return v;
      if (state.startDate && v < state.startDate) return state.startDate;
      if (state.endDate && v > state.endDate)     return state.endDate;
      return v;
    }

    // 2/3 through the season, then snap to the first day of that month.
    // Ensures it's within [start,end] and after start by at least minGapDays.
    function suggestSecondArrivalMonthStart(startISO, endISO, {
      pct = 2/3,       // 67%
      minGapDays = 1   // must be at least this many days after start
    } = {}) {
      if (!startISO || !endISO) return '';
      const start = new Date(startISO + 'T00:00:00Z');
      const end   = new Date(endISO   + 'T00:00:00Z');
      if (isNaN(start) || isNaN(end) || end <= start) return '';
    
      // point ~2/3 through
      const mid = new Date(start.getTime() + (end - start) * pct);
    
      // snap to first of that month (UTC-safe)
      const monthStart = new Date(Date.UTC(mid.getUTCFullYear(), mid.getUTCMonth(), 1));
    
      // enforce min gap from start
      const minAllowed = new Date(Date.UTC(
        start.getUTCFullYear(), start.getUTCMonth(), start.getUTCDate() + minGapDays
      ));
      let picked = monthStart < minAllowed ? minAllowed : monthStart;
    
      // clamp to end
      if (picked > end) picked = new Date(end);
    
      return picked.toISOString().slice(0,10); // YYYY-MM-DD
    }

    const sum = () => state.values.reduce((a,r)=> a + (Number(r.count)||0), 0);

    // ---------- UI ----------
    function ensureMinRows(){
      while (state.values.length < state.minRows) state.values.push({ date:'', count:0 });
    }

    function render(){
      const rows = $('rows');
      rows.innerHTML = '';

      // Show header meta
      $('meta').textContent = `${fromISOToNice(state.startDate) || 'Start'} — ${fromISOToNice(state.endDate) || 'End'} • ${state.totalWorkers} workers`;

      state.values.forEach((row, idx)=>{
        const tr = document.createElement('tr');

        // date cell
        const tdDate = document.createElement('td');
        const inpDate = document.createElement('input');
        inpDate.type = 'date';

        // First row defaults to the job start date
        if (idx === 0 && !row.date && state.startDate) row.date = state.startDate;

        const prev = idx>0 ? (state.values[idx-1]?.date || '') : '';
        const minForThis = idx===0 ? state.startDate : (prev ? nextDay(prev) : state.startDate);
        if (minForThis)    inpDate.min = minForThis;
        if (state.endDate) inpDate.max = state.endDate;

        inpDate.value = row.date || '';
        inpDate.addEventListener('change', ()=>{
          let v = toISO(inpDate.value);
          v = clampDate(v);
          if (idx>0){
            const p = state.values[idx-1]?.date;
            if (p && (!v || v <= p)) v = nextDay(p);
          }
          row.date = v || '';
          inpDate.value = row.date;
          validateAndSend();
          render(); // refresh min/max constraints downstream
        });
        tdDate.appendChild(inpDate);

        // number cell
        const tdNum = document.createElement('td');
        const inpNum = document.createElement('input');
        inpNum.type = 'number';
        inpNum.min = '0';
        inpNum.step = '1';
        inpNum.placeholder = '0';
        inpNum.value = row.count ?? '';
        inpNum.classList.toggle('zero', Number(row.count||0)===0);

        inpNum.addEventListener('input', ()=>{
          const current = Number(row.count)||0;
          const totalBefore = sum() - current;
          const remaining = Math.max(0, (Number(state.totalWorkers)||0) - totalBefore);
          let v = Math.max(0, Math.floor(Number(inpNum.value||0)));
          if (state.totalWorkers > 0) v = Math.min(v, remaining); // clamp to capacity
          row.count = v;
          inpNum.value = String(v);
          inpNum.classList.toggle('zero', v===0);
          validateAndSend(); // updates Total selected
          // no render() here (keeps typing smooth)
          $('totalSelected').textContent = String(sum());
          $('addRow').disabled = (state.totalWorkers > 0 && sum() >= state.totalWorkers);
        });
        tdNum.appendChild(inpNum);

        // actions
        const tdAct = document.createElement('td');
        tdAct.className = 'row-actions';
        const del = document.createElement('button');
        del.type = 'button';
        del.className = 'btn danger';
        del.textContent = 'Remove';
        del.addEventListener('click', ()=>{
          if (state.values.length <= state.minRows) return; // never below 2
          state.values.splice(idx,1);
          render(); validateAndSend();
        });
        tdAct.appendChild(del);

        tr.appendChild(tdDate); tr.appendChild(tdNum); tr.appendChild(tdAct);
        rows.appendChild(tr);
      });

      $('totalSelected').textContent = String(sum());
      $('totalAllowed').textContent  = String(state.totalWorkers);

      // disable remove buttons if at min rows
      const canRemove = state.values.length > state.minRows;
      rows.querySelectorAll('button').forEach(b => b.disabled = !canRemove);

      // disable "Add arrival" if we’re at capacity
      $('addRow').disabled = (state.totalWorkers > 0 && sum() >= state.totalWorkers);
    }

    function addRow(prefill={}){
      state.values.push({ date: prefill.date ?? '', count: prefill.count ?? 0 });
      render(); validateAndSend();
    }

    function setBounds({ startDate, endDate, totalWorkers }){
      if (startDate != null)    state.startDate = toISO(startDate) || '';
      if (endDate   != null)    state.endDate   = toISO(endDate)   || '';
      if (totalWorkers != null) state.totalWorkers = Number(totalWorkers) || 0;
    
      // Always have at least two rows
      ensureMinRows();
    
      // Row 1: force to start date if present
      if (state.startDate) state.values[0].date = state.startDate;
    
      // Row 2: if blank, suggest 2/3 through, snapped to month start and clamped
      if (state.values[1] && !state.values[1].date && state.startDate && state.endDate){
        let suggested = suggestSecondArrivalMonthStart(state.startDate, state.endDate, {
          pct: 2/3,
          minGapDays: 1
        });
    
        // Must be strictly after row 1
        const minSecond = nextDay(state.values[0].date);
        if (suggested && suggested < minSecond) suggested = minSecond;
    
        // Clamp to end
        if (state.endDate && suggested > state.endDate) suggested = state.endDate;
    
        state.values[1].date = suggested || state.values[1].date || '';
      }
    
      // Snap/validate all rows to range and strictly increasing order
      state.values.forEach((r,i)=>{
        r.date = toISO(r.date);
        r.date = clampDate(r.date);
        if (i>0){
          const prev = state.values[i-1]?.date;
          if (prev && (!r.date || r.date <= prev)) r.date = nextDay(prev);
        }
      });
    
      render();
      validateAndSend();
    }

    // ---------- validation / emit ----------
    function errors(){
      const es = [];
      for (let i=0;i<state.values.length;i++){
        const r = state.values[i];
        if (!r.date){ es.push('All rows must have a date.'); break; }
        if (state.startDate && r.date < state.startDate){ es.push('A date is before the job start date.'); break; }
        if (state.endDate   && r.date > state.endDate){ es.push('A date is after the job end date.'); break; }
        if (i>0){
          const p = state.values[i-1].date;
          if (!p){ es.push('Earlier rows must be completed first.'); break; }
          if (r.date <= p){ es.push('Dates must be strictly increasing with no duplicates.'); break; }
        }
      }
      const total = sum();
      if (state.totalWorkers > 0 && total !== state.totalWorkers){
        es.push(`Total selected (${total}) must equal requested (${state.totalWorkers}).`);
      }
      if (state.values.length < state.minRows) es.push('At least two arrival rows are required.');
      return es;
    }

    function serialize(){
      return state.values.map(r=>({ date:r.date, count:Number(r.count)||0 }));
    }

    function validateAndSend(){
      const es = errors();
      $('status').innerHTML = es.length ? `<span class="error">${es[0]}</span>` : 'Looks good. You can submit the form.';
      try {
        JFCustomWidget.sendData({
          value: JSON.stringify(serialize()),
          valid: es.length===0,
          message: es[0] || ''
        });
      } catch(_){}
    }

    // ---------- wire up ----------
    $('addRow').addEventListener('click', ()=>{
      // Only allow a new row if there’s room (or no limit)
      const atCap = state.totalWorkers > 0 && sum() >= state.totalWorkers;
      if (atCap) return;
      addRow();
    });

    // JF lifecycle
    JFCustomWidget.subscribe('ready', function(){
      const sQ = toQID(JFCustomWidget.getWidgetSetting('startFieldId'));
      const eQ = toQID(JFCustomWidget.getWidgetSetting('endFieldId'));
      const nQ = toQID(JFCustomWidget.getWidgetSetting('totalWorkersFieldId'));

      // initial values
      (function initPull(){
        const ids = [sQ,eQ,nQ].filter(Boolean);
        if (!ids.length) { ensureMinRows(); render(); validateAndSend(); return; }
        try {
          JFCustomWidget.getFieldsValueById(ids, (res)=>{
            let map = {};
            if (res && res.type === 'event:receiver') {
              (res.data || []).forEach(r => { map[String(r.selector)] = (r.value && r.value.value) ? r.value.value : r.value; });
            } else {
              map = res || {};
            }
            setBounds({
              startDate: map[sQ] || '',
              endDate:   map[eQ] || '',
              totalWorkers: Number(map[nQ]) || 0
            });
            ensureMinRows();
            render(); validateAndSend();
          });
        } catch(_){
          ensureMinRows();
          render(); validateAndSend();
        }
      })();

      // keep dates synced (watchers normalize to ISO before set)
      startWatcher(sQ, v => setBounds({ startDate: v }));
      startWatcher(eQ, v => setBounds({ endDate: v }));

      // workers: listen for user typing + one late read to catch slow prefill
      if (nQ){
        const key = `input_${nQ}`;
        const h = (v)=> setBounds({ totalWorkers: Number((v&&v.value)||v)||0 });
        try { JFCustomWidget.listenFromField(key, 'change', h); } catch(_){}
        try { JFCustomWidget.listenFromField(key, 'keyup',  h); } catch(_){}
        setTimeout(()=> readByIdOnce(nQ, v => {
          const nVal = Number(v);
          if (!Number.isNaN(nVal) && nVal > 0) setBounds({ totalWorkers: nVal });
        }), 600);
      }
    });

    JFCustomWidget.subscribe('submit', function(){
      const es = errors();
      JFCustomWidget.sendSubmit({ valid: es.length===0, value: JSON.stringify(serialize()) });
    });
  })();
  </script>
</body>
</html>



