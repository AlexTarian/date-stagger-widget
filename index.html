<!doctype html>
<html>
  <head>
    <script src="//js.jotform.com/JotFormCustomWidget.min.js"></script>
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
  </head>
  <style></style>
  <body>
    <div id="reviewArea">
    </div>
    <script type="text/javascript">
      function tableExampleForCleaningDepot() {
        // get widget parameters if any using getWidgetSettings for all, or getWidgetSetting('name') for a specific one.
        // const params = JFCustomWidget.getWidgetSettings();


        // exposed functions
        this.init = init;
        this.getData = getData;
        const otherFields = [
          'control_textbox',
          'control_textarea',
          'control_dropdown',
          'control_datetime',
          'control_phone',
          'control_fullname',
          'control_email'
        ]


        function getFieldsByX(){
          console.log("Running getFieldsByX")
          JFCustomWidget.getFieldsValueByName(otherFields, function(res){
              setTimeout(console.log(`Here's the data ${JSON.stringify(res, null, 2)}`), 500)
          })
        }


        // initialization of the widget
        function init(formData) {
          console.log("Hello world!");
          getFieldsByX()
        }


        // get widget data
        function getData() {
          return {
            valid: true,
            value: "TEST"
          };
        }
      }


      // always subscribe to ready event and implement widget related code
      // inside callback function , it is the best practice while developing widgets
      JFCustomWidget.subscribe("ready", function (data) {
        var widget = new tableExampleForCleaningDepot();
        widget.init(data);


        JFCustomWidget.subscribe("submit", function () {
          JFCustomWidget.sendSubmit(widget.getData());
        });
      });
    </script>
  </body>
</html>


<!-- <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arrival Stagger Widget</title>
  <script>
    function __onJFReadyLoad() {
      if (typeof window.__bindJotformOnce === 'function') window.__bindJotformOnce();
    }
  </script>
  <script async src="https://js.jotform.com/JotFormCustomWidget.min.js?onload=__onJFReadyLoad"></script>
  <style>
    :root {
      --radius: 14px;
      --shadow: 0 6px 24px rgba(0,0,0,.08);
      --border: 1px solid rgba(0,0,0,.08);
      --gap: 10px;
      --pad: 14px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    * { box-sizing: border-box; }
    body { font-family: var(--font); margin: 0; padding: var(--pad); background: #fafafa; color: #111; }
    .widget { max-width: 760px; margin: 0 auto; background: #fff; border-radius: var(--radius); box-shadow: var(--shadow); border: var(--border); overflow: hidden; }
    header { padding: 12px var(--pad); display: flex; align-items: center; justify-content: space-between; border-bottom: var(--border); background: #fcfcfc; }
    header h1 { font-size: 16px; margin: 0; font-weight: 600; }
    header .meta { font-size: 12px; color: #E2E2E2; }
    .content { padding: var(--pad); }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 8px; }
    th { font-size: 12px; color: #555; font-weight: 600; border-bottom: var(--border); }
    tr + tr td { border-top: var(--border); }
    input[type="date"], input[type="number"] { width: 100%; padding: 10px; border-radius: 10px; border: 1px solid #d9d9d9; outline: none; }
    input.zero { border-color: #b00020; color: #b00020; background: #fff5f5; }
    input[type="number"] { -moz-appearance: textfield; }
    input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    .row-controls { display: flex; gap: 6px; justify-content: flex-end; }
    .btn { border-radius: 999px; border: 1px solid #d9d9d9; background: #fff; padding: 10px 14px; cursor: pointer; font-weight: 600; }
    .btn[disabled] { opacity: .5; cursor: not-allowed; }
    
    .btn.danger[disabled] { opacity: .5; }
    .stack { display: flex; gap: var(--gap); align-items: center; flex-wrap: wrap; }
    .footer { display: flex; justify-content: space-between; align-items: center; padding-top: 10px; }
    .pill { font-size: 12px; padding: 6px 10px; border-radius: 999px; background: #f2f2f2; border: 1px solid #e5e5e5; }
    .error { color: #b00020; font-weight: 600; }
    .muted { color: #E2E2E2; }
    .hint { font-size: 12px; color: #555; }
    /* Button color overrides */
  .btn.primary { background: #0047AB !important; color: #fff !important; border-color: #0047AB !important; }
  .btn.primary:hover { filter: brightness(0.95); }
  .btn.danger { background: #c62828 !important; color: #fff !important; border-color: #c62828 !important; }
  .btn.danger:hover { filter: brightness(0.95); }
</style>
</head>
<body>
  <div class="widget" id="widget">
    <header>
      <h1>Staggered Arrivals (v19)</h1>
      <div class="meta" id="jobMeta">Start — End • 0 workers</div>
    </header>
    <div class="content">
      <table>
        <thead>
          <tr>
            <th style="width: 60%">Arrival date</th>
            <th style="width: 30%"># of workers</th>
            <th style="width: 10%"></th>
          </tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>

      <div class="footer">
        <div class="stack">
          <button class="btn primary" id="addRowBtn" type="button">+ Add arrival</button>
          <span class="hint">Minimum 2 rows. No max.</span>
        </div>
        <!-- Debug: what the widget is receiving -->
        <div id="debug-params" style="margin-top:12px; padding:10px; border:1px solid #ddd; border-radius:8px; background:#f8fafc; font:12px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#0f172a;">
          <div><strong>Widget settings</strong> → <span id="dbg-settings">{}</span></div>
          <div><strong>values.keys</strong> → <span id="dbg-keys">[]</span></div>
          <div><strong>Resolved</strong> → start=<span id="dbg-start">(none)</span> &nbsp; end=<span id="dbg-end">(none)</span> &nbsp; total=<span id="dbg-total">(none)</span></div>
          <div id="dbg-note" style="margin-top:6px;color:#475569;">(This panel is for debugging only; you can remove it later.)</div>
          <div style="margin:.75rem 0; font: 14px system-ui;">
            <div><strong>Status:</strong> <span id="status">—</span></div>
            <div><strong>Note:</strong> <span id="dbg-note">—</span></div>
          </div>
        </div>
        <div class="stack">
          <span class="pill">Total selected: <strong id="totalSelected">0</strong></span>
          <span class="pill">Requested: <strong id="totalAllowed">0</strong></span>
        </div>
      </div>

      <div id="status" class="hint" style="margin-top:10px"></div>
    </div>
  </div>
  <script>
    // === ULTRA-LOUD DIAGNOSTICS (runs ASAP) ===
    (function(){
      const put  = (id, msg) => { const el = document.getElementById(id); if (el) el.textContent = msg; };
      const push = (id, msg) => { const el = document.getElementById(id); if (el) el.textContent += (el.textContent? "\n":"") + msg; };
      const STATUS_ID = 'status';
      const NOTE_ID   = 'dbg-note';
      const ts = () => new Date().toISOString().replace('T',' ').replace('Z','');
    
      put(STATUS_ID, 'script alive @ ' + ts());
      window.addEventListener('error', e => { push(STATUS_ID, 'JS error @ ' + ts() + ': ' + (e.message || e)); });
      window.addEventListener('unhandledrejection', e => { push(STATUS_ID, 'Promise error @ ' + ts() + ': ' + ((e.reason && e.reason.message) || e.reason || e)); });
    
      const env = [];
      env.push('href=' + location.href);
      env.push('referrer=' + document.referrer);
      env.push('JF now=' + !!window.JFCustomWidget);
      put(NOTE_ID, env.join(' | '));
    
      // Fallback boot if nothing else calls boot()
      setTimeout(() => {
        if (!window.__didBoot) {
          push(STATUS_ID, 'fallback boot @ ' + ts());
          try {
            if (typeof window.boot === 'function') {
              window.boot({ startDate:'', endDate:'', totalWorkers:0 });
              window.__didBoot = true;
            } else {
              push(STATUS_ID, 'boot() not defined yet');
            }
          } catch (err) { push(STATUS_ID, 'boot() threw: ' + (err && err.message || err)); }
        }
      }, 1200);
    
      // handy tracer
      window.dbg = (msg) => push(STATUS_ID, (msg || 'dbg') + ' @ ' + ts());
    })();
    
    // optional: dump raw querystring (helps confirm widget params in URL)
    const qsDump = document.getElementById('dbg-qs');
    if (qsDump) qsDump.textContent = location.search;
    
    // quick JF presence probe
    (function(){
      const note = document.getElementById('dbg-note');
      if (note) note.textContent += ' | JF present now: ' + !!window.JFCustomWidget;
      setTimeout(() => {
        const note2 = document.getElementById('dbg-note');
        if (note2) note2.textContent += ' | after 1s: ' + !!window.JFCustomWidget;
      }, 1000);
    })();
    
    // ===== Elements
    const els = {
      rows: document.getElementById('rows'),
      add: document.getElementById('addRowBtn'),
      totalSelected: document.getElementById('totalSelected'),
      totalAllowed: document.getElementById('totalAllowed'),
      status: document.getElementById('status'),
      jobMeta: document.getElementById('jobMeta'),
    };
    
    // ===== State
    const state = {
      startDate: null,   // yyyy-mm-dd
      endDate: null,     // yyyy-mm-dd
      totalWorkers: 0,
      values: [],        // [{ date: 'yyyy-mm-dd', count: number }]
      minRows: 2,
    };
    
    // ===== Utils
    function fmtMeta() {
      els.jobMeta.textContent = `${state.startDate || 'Start'} — ${state.endDate || 'End'} • ${state.totalWorkers} workers`;
      els.totalAllowed.textContent = String(state.totalWorkers);
    }
    function clampDateToRange(v) {
      if (!v) return v;
      if (state.startDate && v < state.startDate) return state.startDate;
      if (state.endDate && v > state.endDate)     return state.endDate;
      return v;
    }
    function nextDay(iso) {
      if (!iso) return '';
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return '';
      d.setDate(d.getDate() + 1);
      return d.toISOString().slice(0,10);
    }
    function sumSelected() {
      return state.values.reduce((a, r) => a + (Number(r.count) || 0), 0);
    }
    
    // ===== Render
    function render() {
      els.rows.innerHTML = '';
    
      state.values.forEach((row, idx) => {
        const tr = document.createElement('tr');
    
        // Date cell
        const tdDate = document.createElement('td');
        const date = document.createElement('input');
        date.type = 'date';
        date.required = true;
    
        const prevDate = idx > 0 ? (state.values[idx - 1]?.date || null) : null;
        const minForThis = idx === 0 ? state.startDate : (prevDate ? nextDay(prevDate) : state.startDate);
        if (minForThis)    date.min = minForThis;
        if (state.endDate) date.max = state.endDate;
    
        date.value = row.date || '';
        date.addEventListener('change', () => {
          let newVal = clampDateToRange(date.value);
          if (idx > 0) {
            const prev = state.values[idx - 1]?.date;
            if (prev && (!newVal || newVal <= prev)) newVal = nextDay(prev);
          }
          row.date = newVal || '';
          date.value = row.date;
          validateAndEmit();
          render(); // refresh mins for later rows
        });
        tdDate.appendChild(date);
    
        // Number cell
        const tdNum = document.createElement('td');
        const num = document.createElement('input');
        num.type = 'number';
        num.min = '0';
        num.step = '1';
        num.placeholder = '0';
        num.value = row.count ?? '';
        num.classList.toggle('zero', Number(row.count || 0) === 0);
        num.addEventListener('input', () => {
          const v = Math.max(0, Math.floor(Number(num.value || 0)));
          row.count = v;
          num.value = String(v);
          num.classList.toggle('zero', v === 0);
          validateAndEmit();
        });
        tdNum.appendChild(num);
    
        // Actions cell
        const tdActions = document.createElement('td');
        const del = document.createElement('button');
        del.className = 'btn danger';
        del.textContent = 'Remove';
        del.type = 'button';
        del.addEventListener('click', () => removeRow(idx));
        tdActions.appendChild(del);
    
        tr.appendChild(tdDate);
        tr.appendChild(tdNum);
        tr.appendChild(tdActions);
        els.rows.appendChild(tr);
      });
    
      // Footer + controls
      const total = sumSelected();
      els.totalSelected.textContent = String(total);
    
      const canRemove = state.values.length > state.minRows;
      [...els.rows.querySelectorAll('button')].forEach(btn => btn.disabled = !canRemove);
    
      els.add.disabled = (state.totalWorkers > 0 && total >= state.totalWorkers);
    }
    
    // ===== Core actions
    function addRow(prefill = {}) {
      state.values.push({ date: prefill.date ?? '', count: prefill.count ?? 0 });
      render(); validateAndEmit();
    }
    function removeRow(idx) {
      if (state.values.length <= state.minRows) return;
      state.values.splice(idx, 1);
      render(); validateAndEmit();
    }
    function setBounds({ startDate, endDate, totalWorkers }) {
      if (startDate != null)    state.startDate = startDate;
      if (endDate != null)      state.endDate = endDate;
      if (totalWorkers != null) state.totalWorkers = Number(totalWorkers) || 0;
    
      fmtMeta();
      // Snap existing rows to range and order
      state.values.forEach((r, i) => {
        r.date = clampDateToRange(r.date);
        if (i > 0) {
          const prev = state.values[i-1]?.date;
          if (prev && (!r.date || r.date <= prev)) r.date = nextDay(prev);
        }
      });
      render(); validateAndEmit();
    }
    
    // ===== Validation / serialization
    function validate() {
      const errors = [];
      for (let i = 0; i < state.values.length; i++) {
        const r = state.values[i];
        if (!r.date) { errors.push('All rows must have a date.'); break; }
        if (state.startDate && r.date < state.startDate) { errors.push('A date is before the job start date.'); break; }
        if (state.endDate && r.date > state.endDate) { errors.push('A date is after the job end date.'); break; }
        if (i > 0) {
          const prev = state.values[i-1].date;
          if (!prev) { errors.push('Earlier rows must be completed first.'); break; }
          if (r.date <= prev) { errors.push('Dates must be strictly increasing with no duplicates.'); break; }
        }
      }
      const total = sumSelected();
      if (state.totalWorkers > 0 && total !== state.totalWorkers) {
        errors.push(`Total selected (${total}) must equal requested (${state.totalWorkers}).`);
      }
      if (state.values.length < state.minRows) errors.push('At least two arrival rows are required.');
      return errors;
    }
    function validateAndEmit() {
      const errs = validate();
      if (errs.length) {
        els.status.innerHTML = `<span class="error">${errs[0]}</span>`;
        sendValue({ valid: false, message: errs[0] });
      } else {
        els.status.textContent = 'Looks good. You can submit the form.';
        sendValue({ valid: true });
      }
    }
    function serialize() {
      return state.values.map(r => ({ date: r.date, count: Number(r.count) || 0 }));
    }

    function normalizeFieldIdOrName(raw) {
      // Accept "4", "input_4", "#input_4_pick", "q4_jobStartDate"
      let s = String(raw || '').trim();
      s = s.replace(/^#/, '').replace(/_pick$/i, '');
      if (/^\d+$/.test(s)) return { id: 'input_' + s, name: null };
      const m = s.match(/^input_(\d+)$/);
      if (m) return { id: s, name: null };
      return { id: null, name: s }; // treat anything else as a unique name
    }
    
    function resolveTargets(settings) {
      const s = normalizeFieldIdOrName(settings?.startFieldId);
      const e = normalizeFieldIdOrName(settings?.endFieldId);
      const n = normalizeFieldIdOrName(settings?.totalWorkersFieldId);
      const ids   = [s.id, e.id, n.id].filter(Boolean);
      const names = [s.name, e.name, n.name].filter(Boolean);
      return { ids, names, s, e, n };
    }
    
    // ===== Boot / integration
    els.add.addEventListener('click', () => addRow());
    function boot(initialConfig) {
      if (state.values.length === 0) { addRow(); addRow(); }
      if (initialConfig) {
        setBounds(initialConfig);
        if (state.values[0] && !state.values[0].date && initialConfig.startDate) {
          state.values[0].date = initialConfig.startDate;
          render(); validateAndEmit();
        }
      } else {
        render(); validateAndEmit();
      }
    }
    window.boot = boot; // make sure diagnostics can call it
    
    // Query param testing: ?start=YYYY-MM-DD&end=YYYY-MM-DD&workers=25
    function readQueryConfig() {
      try {
        const u = new URL(location.href);
        const startDate = u.searchParams.get('start') || undefined;
        const endDate   = u.searchParams.get('end')   || undefined;
        const workers   = u.searchParams.get('workers');
        const totalWorkers = workers != null ? Number(workers) : undefined;
        if (startDate || endDate || totalWorkers != null) return { startDate, endDate, totalWorkers };
      } catch (_) {}
      return null;
    }
    
    // ===== Helpers for robust JF reading/listening
    function normalizeFieldId(raw) {
      let s = String(raw || '').trim();
      s = s.replace(/^#/, '');      // drop leading '#'
      s = s.replace(/_pick$/, '');  // Jotform datepicker suffix
      if (/^\d+$/.test(s)) s = 'input_' + s; // allow bare numbers like "4"
      return s;
    }
    function getInitialValues(JF, settings, cb) {
      const dbgSettings = document.getElementById('dbg-settings');
      if (dbgSettings) dbgSettings.textContent = JSON.stringify(settings || {}, null, 2);
    
      const { ids, names, s, e, n } = resolveTargets(settings);
    
      // Try by ID first, then by Name, then fall back to empty
      const done = (vals, source) => {
        const startDate = vals[s.id] ?? vals[s.name] ?? '';
        const endDate   = vals[e.id] ?? vals[e.name] ?? '';
        const twRaw     = vals[n.id] ?? vals[n.name] ?? '';
        const totalWorkers = twRaw ? Number(twRaw) : 0;
    
        // Fill your little debug lines if you have them:
        const dbgKeys = document.getElementById('dbg-keys');
        if (dbgKeys) dbgKeys.textContent = JSON.stringify(Object.keys(vals || {}));
    
        cb({ startDate, endDate, totalWorkers, _source: source });
      };
    
      // Helper to safe-call the APIs (some forms don’t expose both)
      const tryById = (next) => {
        if (JF.getFieldsValueById && ids.length) {
          JF.getFieldsValueById(ids, (map) => {
            if (map && Object.keys(map).length) return done(map, 'byId');
            next();
          });
        } else next();
      };
      const tryByName = (next) => {
        if (JF.getFieldsValueByName && names.length) {
          JF.getFieldsValueByName(names, (map) => {
            if (map && Object.keys(map).length) return done(map, 'byName');
            next();
          });
        } else next();
      };
    
      tryById(() => tryByName(() => done({}, 'empty')));
    }

    function attachJFListeners(JF, settings) {
      const pairs = [
        ['startFieldId', (v)=> setBounds({ startDate: v })],
        ['endFieldId',   (v)=> setBounds({ endDate: v })],
        ['totalWorkersFieldId', (v)=> setBounds({ totalWorkers: Number(v)||0 })],
      ];
      for (const [key, handler] of pairs) {
        const id = normalizeFieldId(settings?.[key]);
        if (!id) continue;
        try { JF.listenFromField(id, 'change', handler); } catch (_){}
        try { JF.listenFromField(id, 'keyup',  handler); } catch (_){}
      }
    }
    
    // ===== Jotform integration (race-proof bind + recovery)
    function tryBindJotform() {
      if (!window.JFCustomWidget) return false; // not ready yet
      const JF = window.JFCustomWidget;
      dbg('JF present=' + !!JF);
    
      let didBoot = false;
      let didReady = false;
    
      // Validate on submit
      JF.subscribe('submit', function(){
        const errs = validate();
        pushValue(errs.length === 0, errs[0] || '');
      });
    
      // Normal path: ready → settings → initial read → boot → listeners
      try {
        JF.subscribe('ready', function(){
          dbg('JF ready');
        
          JF.getWidgetSettings((settings) => {
            dbg('settings keys=' + Object.keys(settings || {}).join(','));
        
            getInitialValues(JF, settings || {}, (vals) => {
              dbg('init via ' + vals._source + ' start=' + vals.startDate + ' end=' + vals.endDate + ' total=' + vals.totalWorkers);
              try {
                boot({ startDate: vals.startDate, endDate: vals.endDate, totalWorkers: vals.totalWorkers });
                window.__didBoot = true;
                pushValue(validate().length === 0);
                dbg('boot ok + initial push');
              } catch (err) {
                dbg('boot error: ' + (err && err.message || err));
              }
            });
        
            // Attach listeners after boot
            attachReactiveListeners(JF, settings || {});
          });
        });
      } catch (_) {}
    
      // Recovery path: if ready never fires but JF exists, pull settings anyway
      setTimeout(() => {
        if (didBoot) return;
        try {
          if (typeof JF.getWidgetSettings === 'function') {
            JF.getWidgetSettings((settings) => {
              const dbgSettings = document.getElementById('dbg-settings');
              if (dbgSettings) dbgSettings.textContent = JSON.stringify(settings || {}, null, 2);
    
              getInitialValuesViaNames(JF, settings || {}, function(vals){
                try {
                  boot({ startDate: vals.startDate, endDate: vals.endDate, totalWorkers: vals.totalWorkers });
                  window.__didBoot = true; didBoot = true;
                  pushValue(validate().length === 0);
                  attachJFListeners(JF, settings || {});
                  const note = document.getElementById('dbg-note');
                  if (note) note.textContent = (note.textContent||'') + ' | recovered without ready';
                  dbg('recovered without ready');
                } catch (err) { dbg('recover boot error: ' + (err && err.message || err)); }
              });
            });
          }
        } catch (e) {
          const s = document.getElementById('status');
          if (s) s.textContent += ' | recovery error: ' + (e && e.message || e);
        }
      }, 1500);
    
      return true;
    }
    
    // Default sendValue for standalone; JF path overwrites via subscribe('submit')
    function pushValue(valid, message) {
      try { JFCustomWidget && JFCustomWidget.sendData({ value: JSON.stringify(serialize()), valid, message: message || '' }); } catch (_){}
    }
    window.sendValue = ({ valid, message }) => pushValue(valid, message);
    
    // Your existing helpers (OPTIONAL): keep only if you still call them elsewhere
    function normalizeFieldKey(raw) {
      if (raw == null) return { lookup: [], listen: [] };
      let s = String(raw).trim();
      if (s.startsWith('#')) s = s.slice(1);
      s = s.replace(/_pick$/i, '');
      if (/^\d+$/.test(s)) {
        const qid = s;
        return { lookup: [qid, `input_${qid}`, `q${qid}`], listen: [`input_${qid}`] };
      }
      const m = s.match(/^input_(\d+)$/);
      if (m) {
        const qid = m[1];
        return { lookup: [qid, s, `q${qid}`], listen: [s] };
      }
      return { lookup: [s], listen: [s] };
    }
    function pickFromValues(values, rawKey) {
      const { lookup } = normalizeFieldKey(rawKey);
      for (const k of lookup) {
        if (Object.prototype.hasOwnProperty.call(values, k)) {
          const v = values[k];
          return (v && typeof v === 'object' && 'value' in v) ? v.value : v;
        }
      }
      return undefined;
    }
    function attachReactiveListeners(JF, settings) {
      const { s, e, n } = resolveTargets(settings);
      const pairs = [
        [s, (v)=> setBounds({ startDate: v })],
        [e, (v)=> setBounds({ endDate: v })],
        [n, (v)=> setBounds({ totalWorkers: Number(v)||0 })],
      ];
      for (const [tgt, handler] of pairs) {
        const keys = [];
        if (tgt.id)   keys.push(tgt.id);
        if (tgt.name) keys.push(tgt.name);
        for (const key of keys) {
          try { JF.listenFromField(key, 'change', handler); } catch (_) {}
          try { JF.listenFromField(key, 'keyup',  handler); } catch (_) {}
        }
      }
    }
    
    // One-time binder, triggered by the script onload in <head>
    let __didBind = false;
    window.__bindJotformOnce = function () {
      if (__didBind) return;
      __didBind = true;
      const bound = tryBindJotform();
      if (!bound) {
        const qc = readQueryConfig();
        boot(qc || { startDate: '', endDate: '', totalWorkers: 0 });
      }
    };
    
    // If JFCustomWidget is already present (rare), bind immediately
    if (window.JFCustomWidget) window.__bindJotformOnce();
    </script>
</body>
</html>


















 -->
