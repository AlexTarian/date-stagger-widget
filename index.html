<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <!-- Jotform bridge -->
    <script src="https://js.jotform.com/JotFormCustomWidget.min.js"></script>

    <!-- ========== ULTRA LOGGER (keep first) ========== -->
    <script>
    (function(){
      const ensureLogPane = () => {
        let pre = document.getElementById('ui-log');
        if (!pre) {
          pre = document.createElement('pre');
          pre.id = 'ui-log';
          pre.style.cssText = 'margin-top:8px;background:#f6f8fa;padding:8px;border-radius:8px;font:12px/1.45 monospace;white-space:pre-wrap;max-height:300px;overflow:auto;';
          document.body && document.body.appendChild(pre);
        }
        return pre;
      };
      const ts  = () => new Date().toISOString();
      const add = (line) => { console.log(line); (ensureLogPane()).textContent += ((ensureLogPane()).textContent? '\n':'') + line; };

      // Global JS error visibility
      window.addEventListener('error', e => add(`[${ts()}] JS error: ${e.message}`));
      window.addEventListener('unhandledrejection', e => add(`[${ts()}] Promise error: ${e.reason && e.reason.message || e.reason}`));

      // Page/env probes
      add(`[${ts()}] page loaded; href=${location.href} referrer=${document.referrer}`);
      add(`[${ts()}] JF present now: ${!!window.JFCustomWidget}`);

      function safeJson(x){ try { return JSON.stringify(x, null, 2); } catch { return String(x); } }

      // Wrap JF API with verbose wrappers once it exists
      (function waitJF(tries=40){
        if (!window.JFCustomWidget) { if (tries<=0){ add(`[${ts()}] JF never appeared`); return; } return setTimeout(()=>waitJF(tries-1), 100); }
        const JF = window.JFCustomWidget;
        const orig = {};
        const capture = (n)=>{ try { orig[n] = JF[n]; } catch(_){} };
        ['subscribe','getWidgetSetting','getWidgetSettings','getFieldsValueById','getFieldsValueByName','listenFromField','sendData','sendSubmit'].forEach(capture);

        if (typeof orig.subscribe === 'function') {
          JF.subscribe = function(eventName, handler){
            add(`[${ts()}] JF.subscribe("${eventName}")`);
            const wrapped = function(arg){ add(`[${ts()}]   ↪ "${eventName}" fired: ${safeJson(arg)}`); return handler && handler(arg); };
            return orig.subscribe.call(JF, eventName, wrapped);
          };
        }
        if (typeof orig.getWidgetSetting === 'function') {
          JF.getWidgetSetting = function(key){ add(`[${ts()}] JF.getWidgetSetting(${safeJson(key)})`); const r = orig.getWidgetSetting.call(JF, key); add(`[${ts()}]   → ${safeJson(r)}`); return r; };
        }
        if (typeof orig.getWidgetSettings === 'function') {
          JF.getWidgetSettings = function(){ add(`[${ts()}] JF.getWidgetSettings()`); const r = orig.getWidgetSettings.call(JF); add(`[${ts()}]   → ${safeJson(r)}`); return r; };
        }
        if (typeof orig.getFieldsValueById === 'function') {
          JF.getFieldsValueById = function(ids, cb){ add(`[${ts()}] JF.getFieldsValueById(${safeJson(ids)})`);
            const wrap = (map)=>{ add(`[${ts()}]   ↩ byId keys: ${Object.keys(map||{}).join(',')}`); add(`[${ts()}]   ↩ byId raw: ${safeJson(map)}`); cb && cb(map); };
            try { return orig.getFieldsValueById.call(JF, ids, wrap); } catch(e){ add(`[${ts()}]   ✖ byId threw: ${e&&e.message||e}`); throw e; }
          };
        }
        if (typeof orig.getFieldsValueByName === 'function') {
          JF.getFieldsValueByName = function(names, cb){ add(`[${ts()}] JF.getFieldsValueByName(${safeJson(names)})`);
            const wrap = (map)=>{ add(`[${ts()}]   ↩ byName keys: ${Object.keys(map||{}).join(',')}`); add(`[${ts()}]   ↩ byName raw: ${safeJson(map)}`); cb && cb(map); };
            try { return orig.getFieldsValueByName.call(JF, names, wrap); } catch(e){ add(`[${ts()}]   ✖ byName threw: ${e&&e.message||e}`); throw e; }
          };
        }
        if (typeof orig.listenFromField === 'function') {
          JF.listenFromField = function(key, evt, handler){ add(`[${ts()}] JF.listenFromField(${safeJson(key)}, ${safeJson(evt)})`);
            const wrap = (v)=>{ add(`[${ts()}]   ↪ listen "${evt}" from ${key}: ${safeJson(v)}`); return handler && handler(v); };
            try { return orig.listenFromField.call(JF, key, evt, wrap); } catch(e){ add(`[${ts()}]   ✖ listen threw: ${e&&e.message||e}`); throw e; }
          };
        }
        if (typeof orig.sendData === 'function') {
          JF.sendData = function(payload){ add(`[${ts()}] JF.sendData(${safeJson(payload)})`); try { return orig.sendData.call(JF, payload); } catch(e){ add(`[${ts()}]   ✖ sendData threw: ${e&&e.message||e}`); throw e; } };
        }
        if (typeof orig.sendSubmit === 'function') {
          JF.sendSubmit = function(payload){ add(`[${ts()}] JF.sendSubmit(${safeJson(payload)})`); try { return orig.sendSubmit.call(JF, payload); } catch(e){ add(`[${ts()}]   ✖ sendSubmit threw: ${e&&e.message||e}`); throw e; } };
        }
        add(`[${ts()}] ✔ JF logging wrappers installed`);
      })();
    })();
    </script>
    <!-- ========== /ULTRA LOGGER ========== -->
  </head>

  <body>
    <div id="reviewArea" style="font:14px system-ui; margin:8px 0;">
      <div><strong>Version</strong> 20</div>
      <div>Start Date: <span id="ui-start">—</span></div>
      <div>End Date: <span id="ui-end">—</span></div>
      <div>Workers: <span id="ui-workers">—</span></div>
    </div>

    <!-- ========== WIDGET LOGIC ========== -->
    <script>
      (function(){
        const $ = (id) => document.getElementById(id);
        const log = (m) => { const el = $('ui-log'); if (el) el.textContent += (el.textContent?'\n':'') + m; console.log(m); };
      
        // --- small utils ---
        const unwrap = v => (v && typeof v === 'object' && 'value' in v) ? v.value : v;
      
        // Convert the event envelope Jotform returns into a simple map: key -> value
        function coerceJFMap(res){
          if (res && res.type !== 'event:receiver') return res || {};
          const out = {};
          const arr = res && Array.isArray(res.data) ? res.data : [];
          for (const row of arr) {
            const key = String(row.selector ?? row.name ?? '');
            if (!key) continue;
            let val = row.value;
            if (val && typeof val === 'object' && 'value' in val) val = val.value;
            out[key] = val;
          }
          return out;
        }
      
        // Coerce event payloads that may be envelopes or plain strings
        function coerceValue(v){
          if (v && typeof v === 'object') {
            if ('value' in v) return v.value;
            if ('data' in v && Array.isArray(v.data) && v.data[0] && 'value' in v.data[0]) return v.data[0].value;
          }
          return v;
        }
      
        // Accept "4", "input_4", "input_4_pick", or unique name; return qid + keys to listen on
        function normalizeParam(raw){
          const s = String((raw && (raw.value ?? raw)) || '').trim();
          let qid = null, name = null, listenKeys = [];
      
          // input_4 / input_4_pick / #input_4_pick
          const m = s.replace(/^#/, '').match(/^input_(\d+)(?:_pick)?$/i);
          if (m) {
            qid = m[1]; // "4"
            const base = `input_${qid}`;
            listenKeys = [base, `${base}_pick`];
            return { qid, name: null, listenKeys };
          }
      
          // pure number "4"
          if (/^\d+$/.test(s)) {
            qid = s;
            const base = `input_${qid}`;
            listenKeys = [base, `${base}_pick`];
            return { qid, name: null, listenKeys };
          }
      
          // treat anything else as unique name
          name = s || null;
          listenKeys = name ? [name] : [];
          return { qid, name, listenKeys };
        }

        // Read a single field by QID and return plain value (handles event envelope)
        function readByIdOnce(qid, cb){
          try {
            JFCustomWidget.getFieldsValueById([qid], (map)=>{
              const m = coerceJFMap(map) || {};
              cb(m[qid] ?? '');
            });
          } catch (_) { cb(''); }
        }
        
        // Start a lightweight watcher that checks a QID every N ms and calls onChange when it actually changes
        function startValueWatcher(qid, { intervalMs = 400, maxIdleMs = 300000 }, onChange){
          if (!qid) return () => {};
          let last = undefined;
          let stopped = false;
          let idleMs = 0;
        
          const tick = () => {
            if (stopped) return;
            readByIdOnce(qid, (val) => {
              if (val !== last) {
                last = val;
                idleMs = 0;
                try { onChange(val); } catch (_) {}
              } else {
                idleMs += intervalMs;
                if (idleMs >= maxIdleMs) { stopped = true; return; }
              }
              setTimeout(tick, intervalMs);
            });
          };
          tick();
          return () => { stopped = true; };
        }
      
        // Listen helper for multiple keys (base + _pick + unique names)
        function listenKeys(keys, handler){
          (keys || []).forEach((key)=>{
            try { JFCustomWidget.listenFromField(key, 'change', v => handler(coerceValue(v))); } catch (_){}
            try { JFCustomWidget.listenFromField(key, 'keyup',  v => handler(coerceValue(v))); } catch (_){}
            try { JFCustomWidget.listenFromField(key, 'blur',   v => handler(coerceValue(v))); } catch (_){}
          });
        }
      
        // Dates: on any event → refetch authoritative value by QID (datepicker can be quirky)
        function wireDate(qid, listenKeysArr, setter){
          if (!qid) return;
          const refresh = () => {
            try {
              JFCustomWidget.getFieldsValueById([qid], (map)=>{
                const m = coerceJFMap(map) || {};
                setter(m[qid] ?? '');
              });
            } catch (_){}
          };
          listenKeys(listenKeysArr, () => refresh());
        }
      
        // Numbers: event value is usually fine directly
        function wireNumber(listenKeysArr, setter){
          listenKeys(listenKeysArr, (v) => setter(Number(v) || 0));
        }
      
        // --- minimal state + emit ---
        const state = { startDate:'', endDate:'', totalWorkers:0 };
        function updateUI(){
          $('ui-start').textContent   = state.startDate || '—';
          $('ui-end').textContent     = state.endDate   || '—';
          $('ui-workers').textContent = String(state.totalWorkers || '—');
        }
        function setState(patch){
          if ('startDate' in patch)    state.startDate = patch.startDate || '';
          if ('endDate' in patch)      state.endDate = patch.endDate || '';
          if ('totalWorkers' in patch) state.totalWorkers = Number(patch.totalWorkers) || 0;
          updateUI();
          pushValue(true);
        }
        function serialize(){ return { ...state }; }
        function pushValue(valid, message){
          try { JFCustomWidget.sendData({ value: JSON.stringify(serialize()), valid, message: message || '' }); } catch(e){}
        }
      
        // Try byId first, then byName, then short poll
        function fetchInitial({ sQ, eQ, nQ, sName, eName, nName }, done){
          const ids   = [sQ, eQ, nQ].filter(Boolean);
          const names = [sName, eName, nName].filter(Boolean);
          const result = { startDate:'', endDate:'', totalWorkers:0 };
      
          const setFrom = (map, tag) => {
            const m = coerceJFMap(map) || {};
            if (sQ    && m[sQ]    != null) result.startDate    = m[sQ]    || result.startDate;
            if (eQ    && m[eQ]    != null) result.endDate      = m[eQ]    || result.endDate;
            if (nQ    && m[nQ]    != null) result.totalWorkers = Number(m[nQ] || result.totalWorkers || 0);
            if (sName && m[sName] != null) result.startDate    = m[sName] || result.startDate;
            if (eName && m[eName] != null) result.endDate      = m[eName] || result.endDate;
            if (nName && m[nName] != null) result.totalWorkers = Number(m[nName] || result.totalWorkers || 0);
          };
      
          const tryById = (next) => {
            if (!ids.length || typeof JFCustomWidget.getFieldsValueById !== 'function') return next();
            JFCustomWidget.getFieldsValueById(ids, (map)=>{ setFrom(map, 'byId'); next(); });
          };
          const tryByName = (next) => {
            if (!names.length || typeof JFCustomWidget.getFieldsValueByName !== 'function') return next();
            JFCustomWidget.getFieldsValueByName(names, (map)=>{ setFrom(map, 'byName'); next(); });
          };
      
          tryById(()=> tryByName(()=> {
            if (result.startDate || result.endDate || result.totalWorkers) return done(result, 'immediate');
            let tries = 12; // ~3.6s
            (function tick(){
              if (--tries < 0) return done(result, 'empty');
              tryById(()=> tryByName(()=> {
                if (result.startDate || result.endDate || result.totalWorkers) return done(result, 'polled');
                setTimeout(tick, 300);
              }));
            })();
          }));
        }
      
        // --- main wiring ---
        JFCustomWidget.subscribe("ready", function(){
          log('ready');
      
          // read settings (IDs or names)
          const s = normalizeParam(JFCustomWidget.getWidgetSetting('startFieldId'));
          const e = normalizeParam(JFCustomWidget.getWidgetSetting('endFieldId'));
          const n = normalizeParam(JFCustomWidget.getWidgetSetting('totalWorkersFieldId'));
      
          log(`normalized → sQ=${s.qid} eQ=${e.qid} nQ=${n.qid} | sListen=${(s.listenKeys||[]).join('+')} eListen=${(e.listenKeys||[]).join('+')} nListen=${(n.listenKeys||[]).join('+')}`);
      
          // initial pull
          fetchInitial(
            { sQ:s.qid, eQ:e.qid, nQ:n.qid, sName:s.name, eName:e.name, nName:n.name },
            (vals, how) => { log(`initial resolved (${how}) → ${JSON.stringify(vals)}`); setState(vals); }
          );
      
          // live sync (use listenKeys from normalizeParam)
          wireDate(s.qid, s.listenKeys, (v)=> setState({ startDate: v }));
          wireDate(e.qid, e.listenKeys, (v)=> setState({ endDate: v }));
          wireNumber(n.listenKeys,      (v)=> setState({ totalWorkers: v }));
          
          // Add resilient watchers for date fields (covers cases where no events fire)
          const stopWatchStart = startValueWatcher(s.qid, { intervalMs: 400, maxIdleMs: 300000 }, (v)=> setState({ startDate: v }));
          const stopWatchEnd   = startValueWatcher(e.qid, { intervalMs: 400, maxIdleMs: 300000 }, (v)=> setState({ endDate: v }));

          const stopWatchWorkers = startValueWatcher(n.qid, { intervalMs: 400, maxIdleMs: 300000 }, (v)=> {
            const nVal = Number(v);
            if (!Number.isNaN(nVal)) setState({ totalWorkers: nVal });
          });
          
          // (optional) if you *expect* Workers to be prefilled and want to catch it later,
          // add a one-time delayed read since your logs show "" at load:
          setTimeout(()=> {
            if (state.totalWorkers === 0) {
              readByIdOnce(n.qid, (v)=> {
                const nVal = Number(v);
                if (!Number.isNaN(nVal) && nVal > 0) setState({ totalWorkers: nVal });
              });
            }
          }, 800);
      
          log(`listening on → start:[${(s.listenKeys||[]).join(', ')}] end:[${(e.listenKeys||[]).join(', ')}] workers:[${(n.listenKeys||[]).join(', ')}]`);
      
          // submit
          JFCustomWidget.subscribe("submit", function(){
            JFCustomWidget.sendSubmit({ valid: true, value: JSON.stringify(serialize()) });
          });
        });
      })();
      </script>
    <!-- ========== /WIDGET LOGIC ========== -->
  </body>
</html>




