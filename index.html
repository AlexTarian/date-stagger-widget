<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arrival Stagger Widget</title>
  <style>
    :root {
      --radius: 14px;
      --shadow: 0 6px 24px rgba(0,0,0,.08);
      --border: 1px solid rgba(0,0,0,.08);
      --gap: 10px;
      --pad: 14px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    * { box-sizing: border-box; }
    body { font-family: var(--font); margin: 0; padding: var(--pad); background: #fafafa; color: #111; }
    .widget { max-width: 760px; margin: 0 auto; background: #fff; border-radius: var(--radius); box-shadow: var(--shadow); border: var(--border); overflow: hidden; }
    header { padding: 12px var(--pad); display: flex; align-items: center; justify-content: space-between; border-bottom: var(--border); background: #fcfcfc; }
    header h1 { font-size: 16px; margin: 0; font-weight: 600; }
    header .meta { font-size: 12px; color: #666; }
    .content { padding: var(--pad); }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 8px; }
    th { font-size: 12px; color: #555; font-weight: 600; border-bottom: var(--border); }
    tr + tr td { border-top: var(--border); }
    input[type="date"], input[type="number"] { width: 100%; padding: 10px; border-radius: 10px; border: 1px solid #d9d9d9; outline: none; }
    input.zero { border-color: #b00020; color: #b00020; background: #fff5f5; }
    input[type="number"] { -moz-appearance: textfield; }
    input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    .row-controls { display: flex; gap: 6px; justify-content: flex-end; }
    .btn { border-radius: 999px; border: 1px solid #d9d9d9; background: #fff; padding: 10px 14px; cursor: pointer; font-weight: 600; }
    .btn[disabled] { opacity: .5; cursor: not-allowed; }
    $1    .btn.danger { background: #fff; color: #b00020; border-color: #b00020; }
    .btn.danger[disabled] { opacity: .5; }
    .stack { display: flex; gap: var(--gap); align-items: center; flex-wrap: wrap; }
    .footer { display: flex; justify-content: space-between; align-items: center; padding-top: 10px; }
    .pill { font-size: 12px; padding: 6px 10px; border-radius: 999px; background: #f2f2f2; border: 1px solid #e5e5e5; }
    .error { color: #b00020; font-weight: 600; }
    .muted { color: #666; }
    .hint { font-size: 12px; color: #555; }
    /* Button color overrides */
  .btn.primary { background: #0047AB !important; color: #fff !important; border-color: #0047AB !important; }
  .btn.primary:hover { filter: brightness(0.95); }
  .btn.danger { background: #c62828 !important; color: #fff !important; border-color: #c62828 !important; }
  .btn.danger:hover { filter: brightness(0.95); }
</style>
</head>
<body>
  <div class="widget" id="widget">
    <header>
      <h1>Staggered Arrivals (v2)</h1>
      <div class="meta" id="jobMeta">Start — End • 0 workers</div>
    </header>
    <div class="content">
      <table>
        <thead>
          <tr>
            <th style="width: 60%">Arrival date</th>
            <th style="width: 30%"># of workers</th>
            <th style="width: 10%"></th>
          </tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>

      <div class="footer">
        <div class="stack">
          <button class="btn primary" id="addRowBtn" type="button">+ Add arrival</button>
          <span class="hint">Minimum 2 rows. No max.</span>
        </div>
        <div class="stack">
          <span class="pill">Total selected: <strong id="totalSelected">0</strong></span>
          <span class="pill">Requested: <strong id="totalAllowed">0</strong></span>
        </div>
      </div>

      <div id="status" class="hint" style="margin-top:10px"></div>
    </div>
  </div>

  <script>
    // ---- Core, framework-free widget -------------------------------------
    const els = {
      rows: document.getElementById('rows'),
      add: document.getElementById('addRowBtn'),
      totalSelected: document.getElementById('totalSelected'),
      totalAllowed: document.getElementById('totalAllowed'),
      status: document.getElementById('status'),
      jobMeta: document.getElementById('jobMeta'),
    };

    const state = {
      startDate: null, // yyyy-mm-dd
      endDate: null,   // yyyy-mm-dd
      totalWorkers: 0,
      values: [],      // [{date: 'yyyy-mm-dd', count: number}]
      minRows: 2,
    };

    function fmtMeta() {
      els.jobMeta.textContent = `${state.startDate || 'Start'} — ${state.endDate || 'End'} • ${state.totalWorkers} workers`;
      els.totalAllowed.textContent = String(state.totalWorkers);
    }

    function clampDateToRange(v) {
      if (!v) return v;
      if (state.startDate && v < state.startDate) return state.startDate;
      if (state.endDate && v > state.endDate) return state.endDate;
      return v;
    }

    function nextDay(iso) {
      if (!iso) return '';
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return '';
      d.setDate(d.getDate() + 1);
      return d.toISOString().slice(0,10);
    }

    function sumSelected() { return state.values.reduce((a, r) => a + (Number(r.count)||0), 0); }

    function render() {
      els.rows.innerHTML = '';

      state.values.forEach((row, idx) => {
        const tr = document.createElement('tr');

        // --- Date cell
        const tdDate = document.createElement('td');
        const date = document.createElement('input');
        date.type = 'date';
        date.required = true;
        const prevDate = idx > 0 ? (state.values[idx - 1]?.date || null) : null;
        const minForThis = idx === 0 ? state.startDate : (prevDate ? nextDay(prevDate) : state.startDate);
        if (minForThis) date.min = minForThis;
        if (state.endDate) date.max = state.endDate;
        date.value = row.date || '';
        date.addEventListener('change', () => {
          let newVal = clampDateToRange(date.value);
          if (idx > 0) {
            const prev = state.values[idx - 1]?.date;
            if (prev && (!newVal || newVal <= prev)) newVal = nextDay(prev);
          }
          row.date = newVal || '';
          date.value = row.date;
          validateAndEmit();
          render(); // re-render to update mins for subsequent rows
        });
        tdDate.appendChild(date);

        // --- Number cell
        const tdNum = document.createElement('td');
        const num = document.createElement('input');
        num.type = 'number';
        num.min = '0';
        num.step = '1';
        num.placeholder = '0';
        num.value = row.count ?? '';
        num.classList.toggle('zero', Number(row.count || 0) === 0);
        num.addEventListener('input', () => {
          const v = Math.max(0, Math.floor(Number(num.value || 0)));
          row.count = v;
          num.value = String(v);
          num.classList.toggle('zero', v === 0);
          validateAndEmit();
        });
        tdNum.appendChild(num);

        // --- Actions cell
        const tdActions = document.createElement('td');
        const del = document.createElement('button');
        del.className = 'btn danger';
        del.textContent = 'Remove';
        del.type = 'button';
        del.addEventListener('click', () => removeRow(idx));
        tdActions.appendChild(del);

        tr.appendChild(tdDate);
        tr.appendChild(tdNum);
        tr.appendChild(tdActions);
        els.rows.appendChild(tr);
      });

      // Footer state
      const total = sumSelected();
      els.totalSelected.textContent = String(total);

      // Enforce minimum rows (disable removes at min)
      const canRemove = state.values.length > state.minRows;
      [...els.rows.querySelectorAll('button')].forEach(btn => btn.disabled = !canRemove);

      // Disable adding if we've already hit requested total
      els.add.disabled = (state.totalWorkers > 0 && total >= state.totalWorkers);
    }

    function addRow(prefill = {})(prefill = {})(prefill = {}) {
      state.values.push({
        date: prefill.date ?? '',
        count: prefill.count ?? 0,
      });
      render();
      validateAndEmit();
    }

    function removeRow(idx) {
      if (state.values.length <= state.minRows) return; // guard
      state.values.splice(idx, 1);
      render();
      validateAndEmit();
    }

    function setBounds({ startDate, endDate, totalWorkers }) {
      if (startDate) state.startDate = startDate;
      if (endDate) state.endDate = endDate;
      if (Number.isFinite(totalWorkers)) state.totalWorkers = Number(totalWorkers);
      fmtMeta();
      // Snap any existing dates to range
      state.values.forEach(r => r.date = clampDateToRange(r.date));
      render();
      validateAndEmit();
    }

    function validate() {
      const errors = [];
      // Dates present and strictly increasing within range
      for (let i = 0; i < state.values.length; i++) {
        const r = state.values[i];
        if (!r.date) { errors.push('All rows must have a date.'); break; }
        if (state.startDate && r.date < state.startDate) { errors.push('A date is before the job start date.'); break; }
        if (state.endDate && r.date > state.endDate) { errors.push('A date is after the job end date.'); break; }
        if (i > 0) {
          const prev = state.values[i-1].date;
          if (!prev) { errors.push('Earlier rows must be completed first.'); break; }
          if (r.date <= prev) { errors.push('Dates must be strictly increasing with no duplicates.'); break; }
        }
      }
      // Totals: must exactly equal requested
      const total = sumSelected();
      if (state.totalWorkers > 0 && total !== state.totalWorkers) {
        errors.push(`Total selected (${total}) must equal requested (${state.totalWorkers}).`);
      }
      // Require at least 2 rows
      if (state.values.length < state.minRows) errors.push('At least two arrival rows are required.');
      return errors;
    }

    function validateAndEmit() {
      const errors = validate();
      if (errors.length) {
        els.status.innerHTML = `<span class="error">${errors[0]}</span>`;
        sendValue({ valid: false, message: errors[0] });
      } else {
        els.status.textContent = 'Looks good. You can submit the form.';
        sendValue({ valid: true });
      }
    }

    function serialize() {
      // Collapse identical dates by summing counts (nice-to-have)
      const map = new Map();
      for (const r of state.values) {
        const k = r.date; const c = Number(r.count)||0;
        map.set(k, (map.get(k)||0) + c);
      }
      const arr = [...map.entries()].map(([date, count]) => ({ date, count }));
      arr.sort((a,b) => a.date.localeCompare(b.date));
      return arr;
    }

    // Hook up UI
    els.add.addEventListener('click', () => addRow());

    // Initialize with two rows; first date auto-populated to start date (once we know it)
    function boot(initialConfig) {
      if (state.values.length === 0) { addRow(); addRow(); }
      if (initialConfig) {
        setBounds(initialConfig);
        // Prefill first date = start date if empty
        if (state.values[0] && !state.values[0].date && initialConfig.startDate) {
          state.values[0].date = initialConfig.startDate;
          render();
          validateAndEmit();
        }
      }
    }

    // ---- Integration surface ---------------------------------------------
    // 1) Standalone usage via query params: ?start=YYYY-MM-DD&end=YYYY-MM-DD&workers=25
    function readQueryConfig() {
      const u = new URL(location.href);
      const startDate = u.searchParams.get('start') || undefined;
      const endDate = u.searchParams.get('end') || undefined;
      const workers = u.searchParams.get('workers');
      const totalWorkers = workers != null ? Number(workers) : undefined;
      if (startDate || endDate || totalWorkers != null) return { startDate, endDate, totalWorkers };
      return null;
    }

    // 2) Jotform Custom Widget integration (best-effort; adapt to exact API names when wiring up)
    // If JFCustomWidget exists, wire listeners to pull host values and push serialized JSON back.
    function tryBindJotform() {
      if (!window.JFCustomWidget) return false;
      const JF = window.JFCustomWidget;

      // Helper: safe settings getter across API versions
      function getSettings(cb){
        try {
          if (typeof JF.getWidgetSettings === 'function') return JF.getWidgetSettings(cb);
          if (typeof JF.requestSettings === 'function')    return JF.requestSettings(cb);
        } catch(_) {}
        cb && cb({});
      }

      // Helper: read host field values given QIDs from settings
      function readHostValues(settings, cb){
        JF.getFieldsValue(function(values){
          let startDate, endDate, totalWorkers;
          const sId = settings.startFieldId, eId = settings.endFieldId, nId = settings.totalWorkersFieldId;
          if (sId && values[sId]) startDate = values[sId].value;
          if (eId && values[eId]) endDate   = values[eId].value;
          if (nId && values[nId]) totalWorkers = Number(values[nId].value);
          cb({ startDate, endDate, totalWorkers });
        });
      }

      function pushValue(valid, message) {
        try {
          JF.sendData({ value: JSON.stringify(serialize()), valid, message: message || '' });
        } catch (e) { /* noop */ }
      }
      window.sendValue = ({ valid, message }) => pushValue(valid, message);

      // Initial boot with settings + values
      JF.subscribe('ready', function(){
        getSettings(function(settings){
          readHostValues(settings, function(vals){
            boot(vals);
            pushValue(validate().length === 0);
          });
        });
      });

      // Live sync: poll host fields periodically (robust across builder/runtime)
      let last = { startDate: undefined, endDate: undefined, totalWorkers: undefined };
      const sync = () => {
        getSettings(function(settings){
          readHostValues(settings, function(vals){
            const changed = (vals.startDate !== last.startDate) || (vals.endDate !== last.endDate) || (Number(vals.totalWorkers||0) !== Number(last.totalWorkers||0));
            if (changed) {
              last = { ...vals };
              setBounds(vals);
            }
          });
        });
      };
      const syncInterval = setInterval(sync, 800);

      // Validate on submit
      JF.subscribe('submit', function(){
        const errs = validate();
        pushValue(errs.length === 0, errs[0] || '');
        try { clearInterval(syncInterval); } catch(_) {}
      });

      return true;
    }

    // Expose sendValue for standalone too
    window.sendValue = ({ valid, message }) => {
      // In standalone, do nothing special
      console.debug('Widget state', { valid, message, data: serialize() });
    };

    // Boot priority: Jotform -> query params -> defaults
    const bound = tryBindJotform();
    if (!bound) {
      const qc = readQueryConfig();
      boot(qc || { startDate: '', endDate: '', totalWorkers: 0 });
    }
  </script>
</body>
</html>
